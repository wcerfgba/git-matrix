{
  "version": 3,
  "file": "ChangesObjectStream.js",
  "sourceRoot": "..",
  "sources": [
    "src/ChangesObjectStream.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# @flow\n\n{ Transform } = require 'stream'\n{ compact, trim, sumBy, debug } = require './util'\n\nmatchCommitHeader = (str) ###: ?Commit ### =>\n  matches = str.match(/^(\\d+) (.*@.*)$/)\n  return null if !matches\n  {\n    time: Number matches[1]\n    email: matches[2]\n    files: []\n  }\n\nparseChangeCount = (count) =>\n  return 1 if count == '-'\n  Number count\n\nparseCommitChanges = (lines) =>\n  lines.map (line) =>\n    parts = line.split '\\t'\n    {\n      linesAdded: parseChangeCount parts[0]\n      linesDeleted: parseChangeCount parts[1]\n      name: parts[2]\n    }\n\n\nHEADER_REGEXP = /^(\\d+) (.*@.*)$/\nFILE_REGEXP = /^(\\d+)\\t(\\d+)\\t(.*)$/\n\nmatchRawCommit = (text) =>\n  lines = text.split '\\n'\n  # console.log lines\n  # First two lines are empty.\n  return false if lines.shift() != ''\n  return false if lines.shift() != ''\n  header = lines.shift().match HEADER_REGEXP\n  return false if !header\n  # Next line is empty.\n  return false if lines.shift() != ''\n  # Last file line should terminate with a newline, leaving an empty string\n  # at the end of the array, so find the first empty string in the array\n  # and terminate the commit there.\n  lastLine = lines.indexOf ''\n  return false if lastLine == -1\n  files = lines.slice 0, lastLine\n  try\n    files = files.map (file) =>\n      file = file.match FILE_REGEXP\n      throw new FileLineDoesNotMatchError if !file\n      {\n        linesAdded: parseChangeCount file[1]\n        linesDeleted: parseChangeCount file[2]\n        name: file[3]\n      }\n  catch FileLineDoesNotMatchError\n    return false\n  commit = {\n    time: Number header[1]\n    email: header[2]\n    files\n  }\n  length = sumBy [\n    '\\n\\n'\n    header[0], '\\n'\n    '\\n'\n    lines.slice(0, lastLine).join '\\n'\n    '\\n'\n  ], (string) => string.length\n  { commit, length }\n\nclass FileLineDoesNotMatchError < Error\n\nclass ChangesObjectStream extends Transform\n  ###::\n  lastCommit: ?Commit\n  ###\n\n  constructor: () ->\n    super({ objectMode: true })\n    @buffer = ''\n    @totalBytesRead = 0\n\n  _transform: (chunk ###: Buffer ###, encoding, callback) ###: void ### ->\n    @totalBytesRead += chunk.length\n    @buffer += chunk.toString()\n    # console.log @buffer\n    while matchedCommit = matchRawCommit @buffer\n      { commit, length } = matchedCommit \n      # console.log matchedCommit\n      @buffer = @buffer.slice length\n      # console.log @buffer\n      @push commit\n      newData = true\n      # debug @buffer\n    callback() if newData\n\n\n\n\n\n\n    # @totalBytesRead += chunk.length\n    # console.log @totalBytesRead, 'total bytes read'\n    # chunk = chunk.toString()\n    # rawCommits = chunk.split '\\n\\n\\n'\n    # rawCommits = rawCommits.map trim\n    # rawCommits = compact rawCommits\n    # commitObjects = rawCommits.reduce (commits, raw) =>\n    #   lines = compact raw.split '\\n'\n    #   commit = matchCommitHeader lines[0]\n    #   if commit\n    #     commit.files = parseCommitChanges lines.slice 1\n    #     @lastCommit = commit\n    #     return [\n    #       ...commits,\n    #       commit\n    #     ]\n    #   commit = @lastCommit\n    #   throw new Error 'Stream must begin at start of a commit' if commit == null\n    #   changedFiles = parseCommitChanges lines\n    #   changedFiles.forEach (changedFile) =>\n    #     existingFile = commit.files.find (file) => file.name == changedFile.name\n    #     if existingFile\n    #       existingFile.linesAdded += changedFile.linesAdded\n    #       existingFile.linesDeleted += changedFile.linesDeleted\n    #     else\n    #       commit.files.push changedFile\n    #   commits\n    # , []\n    # commitObjects.forEach (commit) => @push commit\n    # callback()\n\n\nmodule.exports = ChangesObjectStream"
  ]
}